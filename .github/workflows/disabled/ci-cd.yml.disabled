name: CI/CD Build and Deploy

on:
  push:
    branches: [ dev ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials (via OIDC role)
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: arn:aws:iam::876253813400:role/pat-ah-github-actions-role
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Cache npm registry
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-npm-

      - name: Install dependencies for all services
        run: |
          services=(auth-service users-service rest-service ai-service ingest-service)
          for s in "${services[@]}"; do
            pkg="Backend-Huancavelica-Alertas-Agricolas/services/$s"
            if [ -f "$pkg/package.json" ]; then
              echo "--- Installing dependencies for $s ---"
              if [ -f "$pkg/package-lock.json" ]; then
                npm ci --prefix "$pkg" || npm install --prefix "$pkg"
              else
                npm install --prefix "$pkg"
              fi
            fi
          done

      - name: Run tests per service (if present)
        run: |
          services=(auth-service users-service rest-service ai-service ingest-service)
          for s in "${services[@]}"; do
            pkg="Backend-Huancavelica-Alertas-Agricolas/services/$s"
            if [ -f "$pkg/package.json" ]; then
              echo "--- Running tests for $s ---"
              npm run test --prefix "$pkg" --if-present || true
            fi
          done

      - name: Login to ECR
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
        run: |
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com

      - name: Build, tag (SHA) and push images
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          set -euo pipefail
          SERVICES=(auth-service users-service rest-service ai-service ingest-service)
          REPO_ROOT="${GITHUB_WORKSPACE}/PAT-AH"
          BACKEND_PATH="$REPO_ROOT/Backend-Huancavelica-Alertas-Agricolas"
          for s in "${SERVICES[@]}"; do
            image=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/pat-ah-$s:${IMAGE_TAG}
            echo "Building $s -> $image"
            docker build -t "pat-ah-$s:${IMAGE_TAG}" -f "$BACKEND_PATH/services/$s/Dockerfile" "$BACKEND_PATH"
            docker tag "pat-ah-$s:${IMAGE_TAG}" "$image"
            docker push "$image"
            # Also update the 'latest' tag (optional)
            docker tag "pat-ah-$s:${IMAGE_TAG}" ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/pat-ah-$s:latest || true
            docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/pat-ah-$s:latest || true
          done

      - name: Register new task definition revisions and update ECS services
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          set -euo pipefail
          apt-get update && apt-get install -y jq
          SERVICES=(auth-service users-service rest-service ai-service ingest-service)
          for s in "${SERVICES[@]}"; do
            svc_name="pat-ah-$s"
            echo "Processing ECS service: $svc_name"
            # get current task definition arn
            td_arn=$(aws ecs describe-services --cluster pat-ah-cluster --services $svc_name --query 'services[0].taskDefinition' --output text --region $AWS_REGION)
            echo "Current task definition: $td_arn"
            td_json=$(aws ecs describe-task-definition --task-definition $td_arn --region $AWS_REGION --query 'taskDefinition')
            # replace image for the container that matches the service short name
            container_name="$s"
            new_image="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/pat-ah-${s}:${IMAGE_TAG}"
            echo "New image for $container_name -> $new_image"
            # Update containerDefinitions: if container name matches, set image; else, leave it
            new_td=$(echo "$td_json" | jq --arg cname "$container_name" --arg img "$new_image" '.containerDefinitions |= map(if .name == $cname then .image = $img else . end) | {family: .family, taskRoleArn: .taskRoleArn, executionRoleArn: .executionRoleArn, networkMode: .networkMode, containerDefinitions: .containerDefinitions, volumes: .volumes, placementConstraints: .placementConstraints, requiresCompatibilities: .requiresCompatibilities, cpu: .cpu, memory: .memory, pidMode: .pidMode, ipcMode: .ipcMode}')
            echo "$new_td" > new-taskdef.json
            reg_out=$(aws ecs register-task-definition --cli-input-json file://new-taskdef.json --region $AWS_REGION)
            new_td_arn=$(echo "$reg_out" | jq -r '.taskDefinition.taskDefinitionArn')
            echo "Registered new task def: $new_td_arn"
            aws ecs update-service --cluster pat-ah-cluster --service $svc_name --task-definition $new_td_arn --region $AWS_REGION
            echo "Updated service $svc_name to use $new_td_arn"
          done

      - name: Force ECS redeploy
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
        run: |
          SERVICES=(auth-service users-service rest-service ai-service ingest-service)
          for s in "${SERVICES[@]}"; do
            svc_name="pat-ah-$s"
            echo "Forcing redeploy for $svc_name"
            aws ecs update-service --cluster pat-ah-cluster --service $svc_name --force-new-deployment --region $AWS_REGION
          done

      - name: Done
        run: echo "CI/CD pipeline finished"

  deploy-frontend:
    needs: build-and-deploy
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/dev'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials (via OIDC role)
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: arn:aws:iam::876253813400:role/pat-ah-github-actions-role
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Cache frontend node_modules
        uses: actions/cache@v4
        with:
          path: PAT-AH/Frontend-Huancavelica-Alertas-Agricolas/node_modules
          key: ${{ runner.os }}-frontend-${{ hashFiles('PAT-AH/Frontend-Huancavelica-Alertas-Agricolas/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-frontend-

      - name: Build frontend (Vite)
        run: |
          FRONTEND_DIR="$GITHUB_WORKSPACE/PAT-AH/Frontend-Huancavelica-Alertas-Agricolas"
          cd "$FRONTEND_DIR"
          # If npm ci fails due to out-of-sync lockfile, fall back to npm install
          npm ci || npm install
          npm run build

      - name: Sync `dist/` to S3
        env:
          S3_BUCKET: ${{ secrets.S3_BUCKET }}
        run: |
          FRONTEND_DIST="$GITHUB_WORKSPACE/PAT-AH/Frontend-Huancavelica-Alertas-Agricolas/dist"
          if [ -z "${S3_BUCKET}" ]; then
            echo "S3_BUCKET secret not set. Skipping frontend deployment.";
            exit 0;
          fi
          echo "Syncing $FRONTEND_DIST to s3://$S3_BUCKET"
          aws s3 sync "$FRONTEND_DIST" "s3://$S3_BUCKET" --delete --acl public-read

      - name: Invalidate CloudFront (optional)
        env:
          CLOUDFRONT_DISTRIBUTION_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
        run: |
          if [ -z "${CLOUDFRONT_DISTRIBUTION_ID}" ]; then
            echo "CLOUDFRONT_DISTRIBUTION_ID not set; skipping invalidation.";
            exit 0;
          fi
          set +e
          out=$(aws cloudfront create-invalidation --distribution-id ${CLOUDFRONT_DISTRIBUTION_ID} --paths "/*" 2>&1)
          rc=$?
          if [ $rc -ne 0 ]; then
            echo "CloudFront invalidation failed:"
            echo "$out"
            echo "Continuing without failing the job."
          else
            echo "$out"
          fi
          set -e

      - name: Post-deploy verification (frontend)
        env:
          S3_BUCKET: ${{ secrets.S3_BUCKET }}
          FRONTEND_URL: ${{ secrets.FRONTEND_URL }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          # Determine URL to check: FRONTEND_URL override, otherwise S3 website
          if [ -n "${FRONTEND_URL}" ]; then
            url="${FRONTEND_URL}"
          else
            if [ -z "${S3_BUCKET}" ]; then
              echo "No FRONTEND_URL or S3_BUCKET provided; skipping verification.";
              exit 0;
            fi
            url="http://${S3_BUCKET}.s3-website-${AWS_REGION}.amazonaws.com"
          fi
          echo "Verifying frontend at $url"
          attempts=0
          max=8
          until [ $attempts -ge $max ]
          do
            status=$(curl -s -o /dev/null -w "%{http_code}" "$url" || true)
            echo "Attempt $((attempts+1)): HTTP $status"
            if [ "$status" = "200" ]; then
              echo "Frontend responded 200"
              exit 0
            fi
            attempts=$((attempts+1))
            sleep 5
          done
          echo "Frontend did not respond 200 after $max attempts"
          exit 1
