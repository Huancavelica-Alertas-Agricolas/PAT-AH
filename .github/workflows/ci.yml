name: CI

on:
  push:
    branches: [ dev, circleci-project-setup, dev-monitoring-testing ]
  pull_request:
    branches: [ dev ]
  workflow_dispatch:
    inputs:
      coverage_threshold:
        description: 'Coverage threshold percent (integer) to override default in CI'
        required: false
        default: '70'
      coverage_notification:
        description: 'Coverage threshold for notification-service (optional)'
        required: false
        default: ''
      coverage_alert:
        description: 'Coverage threshold for alert-service (optional)'
        required: false
        default: ''
      coverage_weather:
        description: 'Coverage threshold for weather-service (optional)'
        required: false
        default: ''
      coverage_ai:
        description: 'Coverage threshold for ai-service (optional)'
        required: false
        default: ''
      coverage_ingest:
        description: 'Coverage threshold for ingest-service (optional)'
        required: false
        default: ''
      coverage_users:
        description: 'Coverage threshold for users-service (optional)'
        required: false
        default: ''
      coverage_rest:
        description: 'Coverage threshold for rest-service (optional)'
        required: false
        default: ''

env:
  COVERAGE_THRESHOLD: 70

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [20.x]
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'

      - name: Install dependencies for all services (backend + frontend)
        run: |
          echo "Installing dependencies for all services..."
          SERVICES=(
            "Backend-Huancavelica-Alertas-Agricolas/services/auth-service"
            "Backend-Huancavelica-Alertas-Agricolas/services/users-service"
            "Backend-Huancavelica-Alertas-Agricolas/services/rest-service"
            "Backend-Huancavelica-Alertas-Agricolas/services/weather-service"
            "Backend-Huancavelica-Alertas-Agricolas/services/ai-service"
            "Backend-Huancavelica-Alertas-Agricolas/services/ingest-service"
            "Frontend-Huancavelica-Alertas-Agricolas"
          )
          for pkg in "${SERVICES[@]}"; do
            if [ -f "$pkg/package.json" ]; then
              echo "--- Installing dependencies for $pkg ---"
              if [ -f "$pkg/package-lock.json" ]; then
                npm ci --prefix "$pkg" --legacy-peer-deps || npm install --prefix "$pkg" --legacy-peer-deps
              else
                npm install --prefix "$pkg" --legacy-peer-deps
              fi
            fi
          done

      - name: Run npm audit for all services (produce reports)
        run: |
          echo "Running npm audit for services..."
          mkdir -p "$GITHUB_WORKSPACE/audit-reports"
          for pkg in "${SERVICES[@]}"; do
            if [ -f "$pkg/package.json" ]; then
              name=$(basename "$pkg")
              echo "--- npm audit: $pkg -> $name-audit.json ---"
              (cd "$pkg" && npm audit --json > "$GITHUB_WORKSPACE/audit-reports/$name-audit.json") || echo "{}" > "$GITHUB_WORKSPACE/audit-reports/$name-audit.json"
            fi
          done

      - name: Run ESLint where configured
        run: |
          echo "Running ESLint for packages that declare eslint config..."
          for pkg in "${SERVICES[@]}"; do
            if [ -f "$pkg/package.json" ]; then
              if [ -f "$pkg/.eslintrc" ] || [ -f "$pkg/.eslintrc.js" ] || [ -f "$pkg/.eslintrc.json" ] || grep -q "eslintConfig" "$pkg/package.json" 2>/dev/null; then
                echo "--- ESLint: $pkg ---"
                npx eslint "$pkg" --ext .js,.ts || true
              fi
            fi
          done

      - name: Run tests for rest-service
        working-directory: Backend-Huancavelica-Alertas-Agricolas/services/rest-service
        run: |
          echo "Running tests for rest-service..."
          npm test -- --passWithNoTests

      - name: Run tests for weather-service
        working-directory: Backend-Huancavelica-Alertas-Agricolas/services/weather-service
        run: |
          echo "Running tests for weather-service..."
          npm test -- --passWithNoTests

      - name: Run tests for notification-service
        working-directory: Backend-Huancavelica-Alertas-Agricolas/services/notification-service
        run: |
          echo "Running tests for notification-service..."
          npm test -- --passWithNoTests || true

      - name: Run tests for users-service
        working-directory: Backend-Huancavelica-Alertas-Agricolas/services/users-service
        run: |
          echo "Running tests for users-service..."
          npm test -- --passWithNoTests || true

      - name: Run tests for alert-service
        working-directory: Backend-Huancavelica-Alertas-Agricolas/services/alert-service
        run: |
          echo "Running tests for alert-service..."
          npm test -- --passWithNoTests || true

      - name: Run tests for ai-service
        working-directory: Backend-Huancavelica-Alertas-Agricolas/services/ai-service
        run: |
          echo "Building ai-service image for integration tests (service context)..."
          # Use the service directory as the docker build context so paths like trained-models exist relative to Dockerfile
          docker build -t pat-ah/ai-service:ci -f Dockerfile . || true
          echo "Running tests for ai-service (unit + container E2E)..."
          npm test -- --passWithNoTests || ( echo "ai-service tests failed" && exit 1 )
        timeout-minutes: 30

      - name: Run tests for frontend
        working-directory: Frontend-Huancavelica-Alertas-Agricolas
        run: |
          echo "Running frontend build/tests..."
          npm test -- --passWithNoTests || true
          npm run build || echo "Build failed or not configured"

      - name: Run integration tests (rest-service) using docker-compose
        working-directory: Backend-Huancavelica-Alertas-Agricolas/services/rest-service
        run: |
          echo "Starting docker-compose test stack..."
          # Ensure docker compose command is available on ubuntu runners
          echo "Ensuring docker-compose is installed (plugin + compatibility)..."
          sudo apt-get update -y
          sudo apt-get install -y docker-compose-plugin || true
          # Create compatibility symlink if binary available as CLI plugin
          if [ -f /usr/libexec/docker/cli-plugins/docker-compose ]; then
            sudo ln -sf /usr/libexec/docker/cli-plugins/docker-compose /usr/local/bin/docker-compose || true
          fi
          # Fallback: try python/pip installation (less preferred)
          if ! command -v docker-compose >/dev/null 2>&1; then
            echo "docker-compose not found, trying pip install..."
            python3 -m pip install --user docker-compose || true
            export PATH="$HOME/.local/bin:$PATH"
          fi
          docker-compose -f docker-compose.test.yml up -d
          echo "Running integration commands inside runner..."
          docker-compose -f docker-compose.test.yml run --rm runner sh -c "npm ci --legacy-peer-deps; npx prisma generate; npx prisma db push; npm test -- test/integration/user.integration.spec.js --runInBand"
          echo "Tearing down docker-compose test stack..."
          docker-compose -f docker-compose.test.yml down -v

      - name: Build Docker images (optional)
        run: |
          echo "Building Docker images for services with Dockerfile"
          docker --version || true
          docker build -t pat-ah/rest-service:ci -f Backend-Huancavelica-Alertas-Agricolas/services/rest-service/Dockerfile Backend-Huancavelica-Alertas-Agricolas/services/rest-service || true
          docker build -t pat-ah/ai-service:ci -f Backend-Huancavelica-Alertas-Agricolas/services/ai-service/Dockerfile Backend-Huancavelica-Alertas-Agricolas/services/ai-service || true
          docker build -t pat-ah/weather-service:ci -f Backend-Huancavelica-Alertas-Agricolas/services/weather-service/Dockerfile Backend-Huancavelica-Alertas-Agricolas/services/weather-service || true
          docker build -t pat-ah/frontend:ci -f Frontend-Huancavelica-Alertas-Agricolas/Dockerfile Frontend-Huancavelica-Alertas-Agricolas || true

      - name: Upload test results (optional)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-logs
          path: |
            Backend-Huancavelica-Alertas-Agricolas/services/rest-service/jest.config.json
            Backend-Huancavelica-Alertas-Agricolas/services/weather-service/jest.config.json

      - name: Run per-service coverage and collect artifacts
        if: always()
        run: |
          echo "Running per-service coverage and collecting artifacts"
          mkdir -p coverage-artifacts || true
          SERVICES=(
            "Backend-Huancavelica-Alertas-Agricolas/services/auth-service"
            "Backend-Huancavelica-Alertas-Agricolas/services/users-service"
            "Backend-Huancavelica-Alertas-Agricolas/services/rest-service"
            "Backend-Huancavelica-Alertas-Agricolas/services/weather-service"
            "Backend-Huancavelica-Alertas-Agricolas/services/ai-service"
            "Backend-Huancavelica-Alertas-Agricolas/services/ingest-service"
            "Backend-Huancavelica-Alertas-Agricolas/services/notification-service"
            "Frontend-Huancavelica-Alertas-Agricolas"
          )

          for pkg in "${SERVICES[@]}"; do
            if [ -f "$pkg/package.json" ]; then
              name=$(basename "$pkg")
              echo "--- Service: $pkg -> $name ---"
              mkdir -p "coverage-artifacts/$name"
              (cd "$pkg" && npm ci --no-audit --no-fund) > "coverage-artifacts/${name}-install.log" 2>&1 || \
                (cd "$pkg" && npm install --no-audit --no-fund) >> "coverage-artifacts/${name}-install.log" 2>&1 || true

              # Run coverage script if declared, otherwise fallback to jest json-summary
              if grep -q '"test:cov"' "$pkg/package.json"; then
                (cd "$pkg" && npm run test:cov --if-present) > "coverage-artifacts/${name}-test.log" 2>&1 || true
              else
                (cd "$pkg" && npx jest --coverage --coverageReporters=json-summary --runInBand) > "coverage-artifacts/${name}-test.log" 2>&1 || true
              fi

              # Copy coverage dir if exists
              if [ -d "$pkg/coverage" ]; then
                cp -r "$pkg/coverage" "coverage-artifacts/$name/" || true
              elif [ -f "$pkg/coverage/coverage-summary.json" ]; then
                mkdir -p "coverage-artifacts/$name"
                cp "$pkg/coverage/coverage-summary.json" "coverage-artifacts/$name/coverage-summary.json" || true
              else
                echo "Warning: no coverage produced for $name" >> "coverage-artifacts/${name}-test.log"
              fi
            fi
          done

          echo "Listing coverage-artifacts"
          ls -R coverage-artifacts || true

      - name: Upload coverage artifacts (diagnostic)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-artifacts
          path: coverage-artifacts

      - name: Diagnostic - list coverage summaries
        if: always()
        run: |
          echo "Looking for coverage-summary.json files under coverage-artifacts"
          find coverage-artifacts -type f -name 'coverage-summary.json' -print || true
          echo "Show first 200 lines of each coverage-summary.json (if any)"
          for f in $(find coverage-artifacts -type f -name 'coverage-summary.json' -print || true); do
            echo "--- $f ---"
            head -n 200 "$f" || true
          done

      - name: Collect and upload diagnostic logs
        if: always()
        run: |
          echo "Collecting install/test logs into diagnostics folder"
          mkdir -p diagnostic-logs || true
          # copy any per-service logs from coverage-artifacts
          cp -v coverage-artifacts/*-install.log diagnostic-logs/ 2>/dev/null || true
          cp -v coverage-artifacts/*-test.log diagnostic-logs/ 2>/dev/null || true
        # upload the logs even if empty
      - name: Upload CI diagnostic logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ci-diagnostics
          path: diagnostic-logs

      - name: Run coverage checker (node)
        if: always()
        run: |
          echo "Running node coverage checker"
          node scripts/check-coverage.js --path coverage-artifacts --config coverage.config.json

      - name: Upload audit reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: audit-reports
          path: audit-reports

  dast:
    name: DAST - OWASP ZAP baseline scan
    runs-on: ubuntu-latest
    needs: test
    env:
      # Comma-separated severities that should make the job fail (case-insensitive)
      ZAP_FAIL_SEVERITIES: "High,Critical"
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Ensure docker-compose and docker available
        run: |
          sudo apt-get update -y
          sudo apt-get install -y docker-compose-plugin || true
          if [ -f /usr/libexec/docker/cli-plugins/docker-compose ]; then
            sudo ln -sf /usr/libexec/docker/cli-plugins/docker-compose /usr/local/bin/docker-compose || true
          fi
          docker --version || true

      - name: Start test stack for DAST
        run: |
          echo "Starting docker-compose test stack for DAST..."
          docker-compose -f Backend-Huancavelica-Alertas-Agricolas/services/rest-service/docker-compose.test.yml up -d || docker-compose -f docker-compose.test.yml up -d || true

      - name: Wait for target to be healthy
        run: |
          TARGET_URL=http://localhost:3003/healthz
          echo "Waiting for $TARGET_URL to respond (timeout 120s)..."
          for i in $(seq 1 24); do
            if curl -sSf $TARGET_URL >/dev/null 2>&1; then
              echo "Target healthy"
              exit 0
            fi
            sleep 5
          done
          echo "Target did not become healthy" && exit 1

      - name: Try Action-based OWASP ZAP baseline (portable)
        id: zap_action
        uses: zaproxy/action-baseline@v0.6.0
        with:
          target: 'http://localhost:3003'
        continue-on-error: true

      - name: Fallback: Run OWASP ZAP baseline scan (container, host network)
        if: steps.zap_action.outcome != 'success'
        run: |
          echo "Running OWASP ZAP baseline scan (fallback) against http://localhost:3003"
          # generate both HTML and JSON reports (-r html, -J json)
          docker run --rm --network host -v $PWD:/zap/wrk/:rw owasp/zap2docker-stable zap-baseline.py -t http://localhost:3003 -r zap-report.html -J zap-report.json || true

      - name: Analyze ZAP JSON and fail on configured severities
        id: analyze
        if: always()
        continue-on-error: true
        run: |
          echo "Inspecting zap-report.json for severities in $ZAP_FAIL_SEVERITIES..."
          python3 - <<'PY'
import json,sys,os
path='zap-report.json'
if not os.path.exists(path):
    print('zap-report.json not found, skipping fail-on-alerts check')
    sys.exit(0)
with open(path,'r',encoding='utf-8') as f:
    try:
        j=json.load(f)
    except Exception as e:
        print('Failed to parse zap-report.json:',e)
        sys.exit(0)

severities_env = os.environ.get('ZAP_FAIL_SEVERITIES','High,Critical')
severities = set([s.strip().lower() for s in severities_env.split(',') if s.strip()])
print('Configured fail severities:', severities)

def scan(obj):
    # Prefer explicit 'risk' fields typical in ZAP JSON
    if isinstance(obj, dict):
        if 'risk' in obj and isinstance(obj['risk'], str):
            if obj['risk'].strip().lower() in severities:
                return True, ('risk', obj['risk'], obj)
        for v in obj.values():
            found = scan(v)
            if found[0]:
                return found
    elif isinstance(obj, list):
        for item in obj:
            found = scan(item)
            if found[0]:
                return found
    elif isinstance(obj, str):
        low = obj.lower()
        for sev in severities:
            if sev in low:
                return True, (None, obj, obj)
    return (False, None)

found = scan(j)
if found[0]:
    print('Failing build due to alert:', found[1])
    sys.exit(1)
else:
    print('No configured-severity alerts found in zap-report.json')
    sys.exit(0)
PY

      - name: Upload ZAP report artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: zap-report
          path: |
            zap-report.html
            zap-report.json

      - name: Create GitHub issue for DAST findings
        if: steps.analyze.outcome == 'failure'
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const path = 'zap-report.json';
            let body = `DAST (OWASP ZAP) found alerts in run ${process.env.GITHUB_RUN_ID} for repository ${process.env.GITHUB_REPOSITORY}.\n\n`;
            if (fs.existsSync(path)) {
              try {
                const j = JSON.parse(fs.readFileSync(path, 'utf8'));
                body += 'Summary (first matching alert):\n\n';
                // Try to find first alert with risk field
                function find(obj) {
                  if (!obj) return null;
                  if (typeof obj === 'object') {
                    if (obj.risk) return obj;
                    for (const k of Object.keys(obj)) {
                      const found = find(obj[k]);
                      if (found) return found;
                    }
                  }
                  return null;
                }
                const found = find(j);
                if (found) {
                  body += 'Risk: ' + (found.risk || 'unknown') + '\n';
                  body += 'Alert: ' + (found.name || JSON.stringify(found).slice(0,200)) + '\n\n';
                }
              } catch (e) {
                body += 'Could not parse zap-report.json: ' + e.toString() + '\n\n';
              }
            }
            body += `Download artifacts for full report: ${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`;
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `DAST findings: ${process.env.GITHUB_REPOSITORY} run ${process.env.GITHUB_RUN_ID}`,
              body: body,
            });
            core.setOutput('issue_number', issue.data.number);

      - name: Tear down docker-compose test stack
        if: always()
        run: |
          docker-compose -f Backend-Huancavelica-Alertas-Agricolas/services/rest-service/docker-compose.test.yml down -v || docker-compose -f docker-compose.test.yml down -v || true

  build-and-deploy:
    name: Build and Deploy to AWS (ECR/ECS)
    runs-on: ubuntu-latest
    needs: [test, dast]
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials (via OIDC role)
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: arn:aws:iam::876253813400:role/pat-ah-github-actions-role
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Cache npm registry
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-npm-

      - name: Install dependencies for all services
        run: |
          services=(auth-service users-service rest-service ai-service ingest-service)
          for s in "${services[@]}"; do
            pkg="Backend-Huancavelica-Alertas-Agricolas/services/$s"
            if [ -f "$pkg/package.json" ]; then
              echo "--- Installing dependencies for $s ---"
              if [ -f "$pkg/package-lock.json" ]; then
                npm ci --prefix "$pkg" || npm install --prefix "$pkg"
              else
                npm install --prefix "$pkg"
              fi
            fi
          done

      - name: Run tests per service (if present)
        run: |
          services=(auth-service users-service rest-service ai-service ingest-service)
          for s in "${services[@]}"; do
            pkg="Backend-Huancavelica-Alertas-Agricolas/services/$s"
            if [ -f "$pkg/package.json" ]; then
              echo "--- Running tests for $s ---"
              npm run test --prefix "$pkg" --if-present || true
            fi
          done

      - name: Login to ECR
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
        run: |
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com

      - name: Build, tag (SHA) and push images
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          set -euo pipefail
          SERVICES=(auth-service users-service rest-service ai-service ingest-service)
          REPO_ROOT="${GITHUB_WORKSPACE}"
          BACKEND_PATH="$REPO_ROOT/Backend-Huancavelica-Alertas-Agricolas"
          for s in "${SERVICES[@]}"; do
            image=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/pat-ah-$s:${IMAGE_TAG}
            echo "Building $s -> $image"
            docker build -t "pat-ah-$s:${IMAGE_TAG}" -f "$BACKEND_PATH/services/$s/Dockerfile" "$BACKEND_PATH"
            docker tag "pat-ah-$s:${IMAGE_TAG}" "$image"
            docker push "$image"
            # Also update the 'latest' tag (optional)
            docker tag "pat-ah-$s:${IMAGE_TAG}" ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/pat-ah-$s:latest || true
            docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/pat-ah-$s:latest || true
          done

      - name: Register new task definition revisions and update ECS services
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          set -euo pipefail
          apt-get update && apt-get install -y jq
          SERVICES=(auth-service users-service rest-service ai-service ingest-service)
          for s in "${SERVICES[@]}"; do
            svc_name="pat-ah-$s"
            echo "Processing ECS service: $svc_name"
            td_arn=$(aws ecs describe-services --cluster pat-ah-cluster --services $svc_name --query 'services[0].taskDefinition' --output text --region $AWS_REGION)
            echo "Current task definition: $td_arn"
            td_json=$(aws ecs describe-task-definition --task-definition $td_arn --region $AWS_REGION --query 'taskDefinition')
            container_name="$s"
            new_image="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/pat-ah-${s}:${IMAGE_TAG}"
            echo "New image for $container_name -> $new_image"
            new_td=$(echo "$td_json" | jq --arg cname "$container_name" --arg img "$new_image" '.containerDefinitions |= map(if .name == $cname then .image = $img else . end) | {family: .family, taskRoleArn: .taskRoleArn, executionRoleArn: .executionRoleArn, networkMode: .networkMode, containerDefinitions: .containerDefinitions, volumes: .volumes, placementConstraints: .placementConstraints, requiresCompatibilities: .requiresCompatibilities, cpu: .cpu, memory: .memory, pidMode: .pidMode, ipcMode: .ipcMode}')
            echo "$new_td" > new-taskdef.json
            reg_out=$(aws ecs register-task-definition --cli-input-json file://new-taskdef.json --region $AWS_REGION)
            new_td_arn=$(echo "$reg_out" | jq -r '.taskDefinition.taskDefinitionArn')
            echo "Registered new task def: $new_td_arn"
            aws ecs update-service --cluster pat-ah-cluster --service $svc_name --task-definition $new_td_arn --region $AWS_REGION
            echo "Updated service $svc_name to use $new_td_arn"
          done

      - name: Force ECS redeploy
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
        run: |
          SERVICES=(auth-service users-service rest-service ai-service ingest-service)
          for s in "${SERVICES[@]}"; do
            svc_name="pat-ah-$s"
            echo "Forcing redeploy for $svc_name"
            aws ecs update-service --cluster pat-ah-cluster --service $svc_name --force-new-deployment --region $AWS_REGION
          done

      - name: Done
        run: echo "CI/CD pipeline finished"

  deploy-frontend:
    needs: build-and-deploy
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/dev'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials (via OIDC role)
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: arn:aws:iam::876253813400:role/pat-ah-github-actions-role
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Cache frontend node_modules
        uses: actions/cache@v4
        with:
          path: PAT-AH/Frontend-Huancavelica-Alertas-Agricolas/node_modules
          key: ${{ runner.os }}-frontend-${{ hashFiles('PAT-AH/Frontend-Huancavelica-Alertas-Agricolas/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-frontend-

      - name: Build frontend (Vite)
        run: |
          FRONTEND_DIR="$GITHUB_WORKSPACE/Frontend-Huancavelica-Alertas-Agricolas"
          cd "$FRONTEND_DIR"
          npm ci --legacy-peer-deps || npm install --legacy-peer-deps
          npm run build

      - name: Sync `dist/` to S3
        env:
          S3_BUCKET: ${{ secrets.S3_BUCKET }}
        run: |
          FRONTEND_DIST="$GITHUB_WORKSPACE/Frontend-Huancavelica-Alertas-Agricolas/dist"
          if [ -z "${S3_BUCKET}" ]; then
            echo "S3_BUCKET secret not set. Skipping frontend deployment.";
            exit 0;
          fi
          echo "Syncing $FRONTEND_DIST to s3://$S3_BUCKET"
          aws s3 sync "$FRONTEND_DIST" "s3://$S3_BUCKET" --delete --acl public-read

      - name: Invalidate CloudFront (optional)
        env:
          CLOUDFRONT_DISTRIBUTION_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
        run: |
          if [ -z "${CLOUDFRONT_DISTRIBUTION_ID}" ]; then
            echo "CLOUDFRONT_DISTRIBUTION_ID not set; skipping invalidation.";
            exit 0;
          fi
          set +e
          out=$(aws cloudfront create-invalidation --distribution-id ${CLOUDFRONT_DISTRIBUTION_ID} --paths "/*" 2>&1)
          rc=$?
          if [ $rc -ne 0 ]; then
            echo "CloudFront invalidation failed:"
            echo "$out"
            echo "Continuing without failing the job."
          else
            echo "$out"
          fi
          set -e

      - name: Post-deploy verification (frontend)
        env:
          S3_BUCKET: ${{ secrets.S3_BUCKET }}
          FRONTEND_URL: ${{ secrets.FRONTEND_URL }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          if [ -n "${FRONTEND_URL}" ]; then
            url="${FRONTEND_URL}"
          else
            if [ -z "${S3_BUCKET}" ]; then
              echo "No FRONTEND_URL or S3_BUCKET provided; skipping verification.";
              exit 0;
            fi
            url="http://${S3_BUCKET}.s3-website-${AWS_REGION}.amazonaws.com"
          fi
          echo "Verifying frontend at $url"
          attempts=0
          max=8
          until [ $attempts -ge $max ]
          do
            status=$(curl -s -o /dev/null -w "%{http_code}" "$url" || true)
            echo "Attempt $((attempts+1)): HTTP $status"
            if [ "$status" = "200" ]; then
              echo "Frontend responded 200"
              exit 0
            fi
            attempts=$((attempts+1))
            sleep 5
          done
          echo "Frontend did not respond 200 after $max attempts"
          exit 1
